Implementation plan for stat 518

——————————————————————————————————————————————
prereqs.r--still not adapted to Julia
A file containing all of the preliminary stuff--R packages to load, for instance.
——————————————————————————————————————————————
So far, we need:
  Rcpp
  RcppArmadillo
  inline


——————————————————————————————————————————————
experiment1_settings.jl
The inputs to the forward simulator are central to the implementation, but they will have to change with different experiments. For a given experiment, I will store them in a file named for the experiment.
——————————————————————————————————————————————
Here are the inputs to the forward simulator:
        init_x, the particle counts
        sto_mat, the stoichiometry matrix
        c, reaction rates, MEASURED IN INTENSITY PER SECOND
        T_sim, the time over which to simulate, MEASURED IN SECONDS

——————————————————————————————————————————————
LFSMC.jl
The main inference method for this paper is a sequential Monte Carlo scheme.
Unit tests should:
--feed it garbage: strings, negative numbers and fractions where only positive numbers or integers should be, matrices where it needs vectors, stuff that's the wrong length
--Run it using a simple forward model in place of Gillespie and a simple prior (normal-normal?) and see if the samples come from the right shape
——————————————————————————————————————————————
Given:
    obs_d, vector of data observed incompletely and with measurement error
    obs_t, times at which data is observed
    sigma, the SD of the measurement error model
    h, a bandwidth that is a tuning parameter for the SMC
    num_particles, another parameter of the SMC scheme
    All the inputs of the forward simulator:
        init_x, the particle counts
        sto_mat, the stoichiometry matrix
        c, reaction rates, MEASURED IN INTENSITY PER SECOND
        T_sim, the time over which to simulate, MEASURED IN SECONDS

It verifies:
    init_x contains nonnegative integers
    obs_t is increasing
    obs_t and obs_d are the same length
    h and sigma are positive
    num_particles is a positive integer

Then, it creates other variables:
    n, initialized to the length of obs_t (or obs_d)
    c_samp, an array where the ith element will be a sample from P(c|stuff) where “stuff” is the first i observations. Because the prior is included, i.e. i starts at 0, this will be longer by 1 than obs_t and obs_d. Initialized to sentinel values. If that

    Call a subroutine to get:
    c_samp, a large sample from the prior distribution on the reaction rates
Finally, it carries out the SMC.
    for i from 1 to n:
        Replace c_samp with sample of size num_particles from the next distribution. Use a subroutine SMC_one_step.
    end of i-loop

It returns
——————————————————————————————————————————————


——————————————————————————————————————————————
The subroutine SMC_one_step
This seems to be the most sensible place to parallelize. (?)
——————————————————————————————————————————————
Given:

It verifies:

It returns:
——————————————————————————————————————————————





——————————————————————————————————————————————
Forward simulation files:
gillespie.jl

At the core, written partly in C and called by many other parts of the project, is the forward simulator.

Unit tests should:
--feed it garbage: strings, negative numbers and fractions where only positive numbers or integers should be, matrices where it needs vectors, stuff that's the wrong length
--Run it many times on a simple reaction model and check to see it converge to the true stochastic mean
——————————————————————————————————————————————
Given:

# init_x, the particle counts
# sto_mat, the stoichiometry matrix, the matrix whose i,j entry says how many
#      molecules of type i are consumed by a rxn of type j (net change)
# rxn_entry_mat, the matrix whose i,j entry says how many molecules
#      of type i enter a rxn of type j (not a net change)
# rxn_rates, reaction rates, MEASURED IN INTENSITY PER SECOND
# T_sim, the time over which to simulate, MEASURED IN SECONDS

# It verifies:

# rxn_entry_mat is same size as sto_mat
# init_x is nonnegative integers
# length of init_x matches num rows of sto_mat
# length of rxn_rates matches num cols of sto_mat
# T_sim is nonnegative

Then, it runs the Gillespie algorithm to produce:

rxn_time, vector of times at which reactions occur (for convenience, rxn_time[0] should be 0)
rxn_type, list of reactions that occured (integers that index sto_mat)
x_path, a list of vectors with zero element init_x and i element showing the molecule counts between rxn_time[i] and rxn_time[i].

——————————————————————————————————————————————

